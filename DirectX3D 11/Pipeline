Input Assemblr -> 
정점들 데이터 받아서 폴리곤으로 조립하는 단계.
GPU Vertex Buffer 에 놓기
인덱스 버퍼 저장
premitive topology.

Vertex Shader
로컬 좌표계 -> 월드 좌표계로 전환
카메라가 있으면 카메라가 바라보는 좌표계로 전환
Projection 변환을 톨해 ClipSpace로 변환

카메라 공간 변환
FOV, Aspect에 의해 결정되는 뷰볼륨, 절두체의 영역만 보여지게됨.
VIEW FRUSTUM
NEAR,FAR clip plane
클리핑은 카메라 변환이 아니라 클립->레스터라이저 넘어갈때 수행됨.

투영 변환
월드의 모든 물체를 카메라 공간으로 재배치,
카메라가 보는 2차원 시점으로 변환해야함
투영 변환은 3차원 클립공간으로 변환하는 것이지 2차원 평면으로 바꾸는 게 아님.


테셀레이터 단계
3단계 ( Hull Shader > Tesselation > Domain Shader) 로 진행

Hull Shader
테셀레이터를 사용한다면 Vertext Shader에서 공간변환을 하지 않고 Hull Shader에서 정점 정보를 전달
폴리곤을 어떻게 ,얼마나 분할할 것인가를 결정하는 단계
테셀레이션을 사용하면 정점을 늘려 더욱 사실적인 표현을 가능케함.
테셀레이션은 다각형을 겹치지 않고 작게 만들어 게임에서 사물이나 인물이 더욱 실제감을 부여하는 기술
훌 셰이더는 어떻게 얼마나 더 분할할건지를 결정

Domain Shader
테셀레이터가 출력한 정점마다 한번씩 함수(셰이딩 언어) 호출함
테셀레이션이 활성화되면 기존의 정점쉐이더에서 수행한 것들을 도메인 쉐이더에서 수행
예를들어 공간변환(월드->뷰->투영).
 
테셀레이터는 실제로 자주 사용되지는 않음

실제 게임에선 로우폴리곤, 하이폴리곤 모델을 따로 사전에 구비해두고 상황에 따라 사용하는 모델을 바꿈


Geometric Shader
이것또한 테셀레이터처럼 필수는 아님
기본 폴리곤에서 정점을 추가하거나 삭제하거나 하는 연산을 할 수 있다.
정점 정보를 추가하여 표현할 수 있는 모델이라면 그만큼의 정점정보를 뺴고 저장할 수 있으니 메모리 용량 감소할 수 있고  GPU의 도움을 받아 정점을 추가해주기에 연산속도가 빨라짐
 
한개의 모델을 다수 생성해야할때 이 셰이더를 사용하면 CPU를 통할 필요없이 GPU에서 일괄연산처리해서 효율적(Particle 연산)


레스터리제이션
클립공간까지 온 단계. 다음단계인 레스터라이저
정점들은 삼각형으로 묶여있는데 이 시점부터는 하나의 독자적 도형으로 처리됨
2차원 삼각형 세 정점이 
삼각형의 모든 픽셀마다 PixelShader가 실행됨.
삼각형 세 정점에 할당 되었던 uv, normal, color들이 보간되어 삼각형 내부에 각 픽셀세이터로 넘어옴
DirectX에선 이 과정을 레스터리제이션이라 부르고 고정 파이프라인 단계여서 로직을 프로그래머가 바꿀수 없으며 알아서 동작한다.

클리핑
볼륨공간 바깥에 폴리곤 잘라내기.  

원근 나눗셈 
-> 3차원을 2차원으로(z값을 나눠서)
x,y 는 -1~+1 / z는 0~1 의 범위를 지니게됨

뒷면 제거(back face culling)
눈에 보이는 면만 그리고 안보이는 부분을 제거


뷰포트 전환
각각 디바이스(모니터)에 맞는 크기로 비율변환(정규화 처리됬기에 간편하게 진행가능)

스캔변환(ndc scan transform)
삼각형 하나가 내부에 차지하는 모든 픽셀을(fragment) 생성하는 작업. 정점 데이터로 들어온 데이터들은 보간되서 픽셀세이더로.


픽셀 셰이더
레스터화된 도형에 원하는 색을 입혀서 실제로 출력하게끔 하는 셰이더
텍스처매핑, 노말매핑으로 색을 입혀 표현할 수도 있음
조명처리, 이미지 처리시 이용됨
정점 데이터가 보간된 값이 넘어온다.

outpur Merger에서
깊이 테스트 -> 알파테스트 
이 두 단계와 블렌딩을 거쳐 최종적으로  물체를 어떻게 그릴지 결정  

투명도에 대한 연산도 처리하는 단계(뒤물체와 블렌딩되서 표현됨


컴퓨터 셰이더
파이프라인은 아니고 그래픽 카드에 있는 병렬 연산을 도와주는 기능
렌더링 가속용


버텍스 버퍼
-> 정점 데이터(객체 위치, 법선, 텍스처 좌표)를 CPU에서 GPU 로 이동시켜놓는 곳

인덱스 버퍼(색인)
-> 정점을 효율적으로 재사용하기 위해 사용하는 데이터 구조
-> 정점의 순서를 기록해 삼각형(폴리곤 구조)를 구성하는데 사용
-> 여러 삼각형이 동일한 정점을 공유하기에 인덱스 버퍼를 사용하면 정점 데이터를 줄일 수 있음.(GPU 메모리 절약)

상수버퍼
-> 행렬 연산을 위한 데이터(카메라 위치, 조명 정보, 월드/뷰/프로젝션 행렬)들을 미리 해당 버퍼에 갔다놓기.
-> 메모리 효율성, CPU,GPU 동기화 문제 감소, 속도 증가.


IMGUI
-> 디버깅 UI용 라이브러리
-> Retained Mode 가 아님(UI 내부적으로 상태를 유지하지 않음), 코드에서 직접 그림.

