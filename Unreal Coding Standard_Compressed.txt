https://dev.epicgames.com/documentation/en-us/unreal-engine/epic-cplusplus-coding-standard-for-unreal-engine



[ 저작권 노티 ]

// Copyright Epic Games, Inc. All Rights Reserved.

에픽게임즈에 의해 제공된 소스 파일은 첫줄에 저작권 노티를 해야한다.
만약 이 문장이 없으면 CIS는 에러가 날 것임.



[ 네이밍 컨벤션 ]
- 영어 스펠링과 문법을 준수해야함
- 클래스,타입,변수명 작명시, 각 단어의 첫글자는 capitalized 
- 단어간 밑줄 없음
ex)
Good -> UPrimitiveComponent
Bad -> lastMouseCoordinates, delta_Coordinates

타입명의 첫 약자를 대문자로 앞에 붙여줘야함.
ex)
FSkin, TAttribute

FSking의 경우 인스턴스 명은 Sking이 될 수 있...?

클래스 종류에 따른 클래스 명 접미사 종류
    UObject 상속 -> U
    AActor 상속 -> A
    SWidget 상속 -> S
    abstract Interfaces -> I
    concept-alike struct types -> C
    Enums -> E
    Most other classes -> F

Boolean variables -> b (이건 클래스명이 아닌 변수명)
    ex) bHasFadedIn


//??
Typedefs should be prefixed by whatever is appropriate for that type, such as:
F for typedef of a struct
U for typedef of a UObject
A typedef of a particular template instantiation is no longer a template and should be prefixed accordingly.

    typedef TArray<FMytype> FArrayOfMyTypes;

//??
Disambiguate template parameters from aliases by using an In prefix:
     template <typename InElementType>
     class TContainer
     {
     public:
         using ElementType = InElementType;
     };

//??
Type and variable names are nouns.
Method names are verbs that either describe the method's effect, 
or the return value of a method without an effect.

Macro names should be fully capitalized with words separated by underscores, and prefixed with UE_.
     #define UE_AUDIT_SPRITER_IMPORT

Variable, method, and class names should be:
    Clear
    Unambiguous
    Descriptive

All functions that return a bool should ask a true/false question, 
such as IsVisible() or ShouldClearBuffer().

//??
A procedure (a function with no return value) should use 
a strong verb followed by an Object. 
An exception is, if the Object of the method is the Object it is in. 
In this case, the Object is understood from context. 
Names to avoid include those beginning with 
"Handle" and "Process" because the verbs are ambiguous.
-> void 리턴형은 함수명을 구체적으로 적어야한다~

We encourage you to prefix function parameter names with "Out" if:
The function parameters are passed by reference.
The function is expected to write to that value.

If an In or Out parameter is also a boolean, 
put "b" before the In/Out prefix, such as bOutResult.



Functions that return a value should describe the return value. The name should make clear what value the function returns. This is particularly important for boolean functions. Consider the following two example methods:

    // what does true mean?
    bool CheckTea(FTea Tea);
    
    // name makes it clear true means tea is fresh
    bool IsTeaFresh(FTea Tea);
    
    float TeaWeight;
    int32 TeaCount;
    bool bDoesTeaStink;
    FName TeaName;
    FString TeaFriendlyName;
    UClass* TeaClass;
    USoundCue* TeaSound;
    UTexture* TeaTexture;


When you work in the Unreal Engine codebase, we encourage you to strive to use respectful, inclusive, and professional language.

Word choice applies when you:
    name classes.
    functions.
    data structures.
    types.
    variables.
    files and folders.
    plugins.



[Use of standard libraries]

Historically, UE has avoided direct use of the C and C++ standard libraries 
for the following reasons:
    Replace slow implementations with our own that provide 
    additional control over memory allocation.
However, the standard library has matured and includes functionality 
that we don't want to wrap with an abstraction layer or reimplement ourselves.

When there is a choice between a standard library feature instead of our own,
you should prefer the option that gives superior results. It's also important
to remember that consistency is valued. If a legacy UE implementation is 
no longer serving a purpose, we may choose to deprecate it and migrate 
all usage toward the standard library.

Avoid mixing UE idioms and standard library idioms in the same API. 
The following table lists common idioms along with recommendations on 
when to use them.

    <atomic>
    <type_traits>
    <initializer_list>
    <regex>
    <limits>
    <cmath>
    <cstring> : memcpy() and memset()



[ Comments ]
Write self-documenting code.
    // Bad:
    t = s + l - b;
		
    // Good:
    TotalLeaves = SmallLeaves + LargeLeaves - SmallAndLargeLeaves;

Write useful comments. For example:
    // Bad:
    // increment Leaves
    ++Leaves;
		
    // Good:
    // we know there is another tea leaf
    ++Leaves;


[ Const correctness ]
Const is documentation as much as it is a compiler directive. All code should strive to be const-correct. This includes the following guidelines:
Pass function arguments by const pointer or reference if those arguments are not intended to be modified by the function.
Flag methods as const if they do not modify the object.
Use const iteration over containers if the loop isn't intended to modify the container.

Put the const keyword on the end when making a pointer itself const (rather than what it points to). References can't be "reassigned" anyway, and so can't be made const in the same way.
	// Const pointer to non-const object - pointer cannot be reassigned, but T can still be modified
    T* const Ptr = ...; 
    
    // Illegal
    T& const Ref = ...;

Never use const on a return type. This inhibits move semantics for complex types, and will give compile warnings for built-in types. This rule only applies to the return type itself, not the target type of a pointer or reference being returned.

	// Bad - returning a const array
    const TArray<FString> GetSomeArray();
    
    // Fine - returning a reference to a const array
    const TArray<FString>& GetSomeArray();
    
    // Fine - returning a pointer to a const array
    const TArray<FString>* GetSomeArray();
    
    // Bad - returning a const pointer to a const array
    const TArray<FString>* const GetSomeArray();

Class comments should include:
    A description of the problem this class solves.
    The reason why was this class created.

//??
Multi-line method comments should include:
Function purpose: Documents the problem this function solves. As previously stated, comments document intent, and code documents implementation.
Parameter comments: Each parameter comment should include:
units of measure;
the range of expected values;
"impossible" values;
and the meaning of status/error codes.
Return comment: Documents the expected return value, just as an output variable is documented. To avoid redundancy, an explicit @return comment should not be used if the sole purpose of the function is to return this value and that is already documented in the function purpose.
Extra information: @warning, @note, @see, and @deprecated can optionally be used to document additional relevant information. Each should be declared on their own line following the rest of the comments.



[ Auto ]

You shouldn't use auto in C++ code, except for the few exceptions listed below. Always be explicit about the type you're initializing. This means that the type must be plainly visible to the reader. This rule also applies to the use of the var keyword in C#.

    When you need to bind a lambda to a variable, as lambda types are not expressible in code.



[ Default Member Initializers ]
Default member initializers can be used to define the defaults of a class inside the class itself:

	UCLASS()
    class UTeaOptions : public UObject
    {
        GENERATED_BODY()
    
    public:
        UPROPERTY()
        int32 MaximumNumberOfCupsPerDay = 10;
    
        UPROPERTY()
        float CupWidth = 11.5f;
    
        UPROPERTY()
        FString TeaType = TEXT("Earl Grey");
    
        UPROPERTY()
        EDrinkingStyle DrinkingStyle = EDrinkingStyle::PinkyExtended;
    };
Code written like this has the following benefits:
    It doesn't need to duplicate initializers across multiple constructors.
    It isn't possible to mix the initialization order and declaration order.
    The member type, property flags, and default values are all in one place. This helps readability and maintainability.
However, there are also some downsides:
    Any change to the defaults requires a rebuild of all dependent files.
    Headers can't change in patch releases of the engine, so this style can limit the kinds of fixes that are possible.
    Some things can't be initialized in this way, such as base classes, UObject subobjects, pointers to forward-declared types, values deduced from constructor arguments, and members initialized over multiple steps.
    Putting some initializers in the header and the rest in constructors in the .cpp file, can reduce readability and maintainability.

Use your best judgment when deciding whether to use default member initializers. As a rule of thumb, default member initializers make more sense with in-game code than engine code. Consider using config files for default values.



[ Code Formatting ]

Brace wars are foul. Epic Games has a long standing usage pattern of putting braces on a new line. Please adhere to this usage, regardless of the size of the function or block. For example:

    // Bad
    int32 GetSize() const { return Size; }
    
    // Good
    int32 GetSize() const
    {
        return Size;
    }

If Else_
    	if (bHaveUnrealLicense)
    {
        InsertYourGameHere();
    }
    else
    {
        CallMarkRein();
    }


[ Switch Statements ]
Except for empty cases (multiple cases having identical code), switch case statements should explicitly label that a case falls through to the next case. Either include a break, or include a "falls through" comment in each case. Other code control-transfer commands (return, continue, and so on) are fine as well.
Always have a default case. Include a break just in case someone adds a new case after the default.

	switch (condition)
    {
        case 1:
            ...
            // falls through
    
        case 2:
            ...
            break;
    
        case 3:
            ...
            return;
    
        case 4:
        case 5:
            ...
            break;
    
        default:
            break;
    }



[ Namespaces ]

Using declarations:
Do not put using declarations in the global scope, even in a .cpp file (it will cause problems with our "unity" build system.)

Most UE code is currently not wrapped in a global namespace.
Be careful to avoid collisions in the global scope, especially when using or including third party code.

It's okay to put using declarations within another namespace, or within a function body.

Macros cannot live in a namespace.
They should be prefixed with UE_ instead of living in a namespace, for example UE_LOG.



[ Pyhsical Dependencies ]
File names should not be prefixed where possible.
For example, Scene.cpp instead of UScene.cpp. This makes it easy to use tools like Workspace Whiz or Visual Assist's Open File in Solution, by reducing the number of letters needed to identify the file you want.

All headers should protect against multiple includes with the #pragma once directive.

Forward declarations are preferred to including headers.



[ General Style Issues ]
Minimize dependency distance.
    When code depends on a variable having a certain value, try to set that variable's value right before using it. Initializing a variable at the top of an execution block, and not using it for a hundred lines of code, gives lots of space for someone to accidentally change the value without realizing the dependency. Having it on the next line makes it clear why the variable is initialized the way it is and where it is used.

Split methods into sub-methods where possible.
It is easier for someone to look at a big picture, and then drill down to the interesting details, than it is to start with the details and reconstruct the big picture from them. In the same way, it is easier to understand a simple method, that calls a sequence of several well-named sub-methods, than it is to understand an equivalent method that simply contains all the code in those sub-methods.

Leave a blank line at the end of the file.
All .cpp and .h files should include a blank line, to coordinate with gcc.

Debug code should either be useful and polished, or not checked in.
Debug code that is intermixed with other code makes the other code harder to read.

    #if !(UE_BUILD_SHIPPING)
        UE_LOG(LogTemp, Warning, TEXT("Speed=%f"), Speed);
    #endif  

Always use the TEXT() macro around string literals.
Without the TEXT() macro, code that constructs FStrings from literals will cause an undesirable string conversion process.
-> Text Mcro : TChar[] 형식
-> "Str..." : char[] 형식
-> FString에 그냥 문자리터럴 대입시 암묵적 형변환이 발생.
-> 컴파일타임에 플랫폼 맞춤 처리 불가. 매번 형변환 비용 발생.

Use intermediate variables to simplify complicated expressions.
If you have a complicated expression, it can be easier to understand if you split it into sub-expressions, that are assigned to intermediate variables, with names describing the meaning of the sub-expression within the parent expression. For example:

     if ((Blah->BlahP->WindowExists->Etc && Stuff) &&
        !(bPlayerExists && bGameStarted && bPlayerStillHasPawn &&
        IsTuesday())))
    {
        DoSomething();
    }

Should be replaced with:
    const bool bIsLegalWindow = Blah->BlahP->WindowExists->Etc && Stuff;
    const bool bIsPlayerDead = bPlayerExists && bGameStarted && bPlayerStillHasPawn && IsTuesday();
    if (bIsLegalWindow && !bIsPlayerDead)
    {
        DoSomething();
    }


Pointers and references should only have one space to the right of the pointer or reference.
This makes it easy to quickly use Find in Files for all pointers or references to a certain type. For example:

    // Use this
    FShaderType* Ptr
        
    // Do not use these:
    FShaderType *Ptr
    FShaderType * Ptr


Avoid using anonymous literals in function calls.
Prefer named constants which describe their meaning. This makes intent more obvious to a casual reader as it avoids the need to look up the function declaration to understand it.
    // Old style
    Trigger(TEXT("Soldier"), 5, true);.
        
    // New style
    const FName ObjectName                = TEXT("Soldier");
    const float CooldownInSeconds         = 5;
    const bool bVulnerableDuringCooldown  = true;
    Trigger(ObjectName, CooldownInSeconds, bVulnerableDuringCooldown);


Avoid defining non-trivial static variables in headers.
Non-trivial static variables cause an instance to be compiled into in every translation unit that includes that header:
    // SomeModule.h
    static const FString GUsefulNamedString = TEXT("String");
        
    // *Replace the above with:*
        
    // SomeModule.h
    extern SOMEMODULE_API const FString GUsefulNamedString;
        
    // SomeModule.cpp
    const FString GUsefulNamedString = TEXT("String");    

-> trivial static : static const int32 MaxCount = 10;
-> non trivial static: static const FString Name = TEXT("Hello");
-> 헤더에 non-trivial이 있는 경우 include된 파일마다 복잡한 프로세스를 처리하기에 대형 프로젝트일수록 비용이 크게 부과됨.
-> 헤더에선 extern으로 선언만하고, cpp에 static실 인스턴스를 만들어 이용하기.



[ API Design Guidelines ]
Boolean function parameters should be avoided.
In particular, boolean parameters should be avoided for flags passed to functions. These have the same anonymous literal problem as mentioned previously, but they also tend to multiply over time as APIs get extended with more behavior. Instead, prefer an enum
It is acceptable to use bools as arguments when they are the complete state to be passed to a function like a setter, such as void FWidget::SetEnabled(bool bEnabled). Though consider refactoring if this changes.


Avoid overly-long function parameter lists.
If a function takes many parameters then consider passing a dedicated struct instead:
    // Old style
    TUniquePtr<FCup[]> MakeTeaForParty(const FTeaFlags* TeaPreferences, uint32 NumCupsToMake, FKettle* Kettle, ETeaType TeaType = ETeaType::EnglishBreakfast, float BrewingTimeInSeconds = 120.0f);
        
    // New style
    struct FTeaPartyParams
    {
        const FTeaFlags* TeaPreferences       = nullptr;
        uint32           NumCupsToMake        = 0;
        FKettle*         Kettle               = nullptr;
        ETeaType         TeaType              = ETeaType::EnglishBreakfast;
        float            BrewingTimeInSeconds = 120.0f;
    };
    TUniquePtr<FCup[]> MakeTeaForParty(const FTeaPartyParams& Params);


When declaring a virtual function in a derived class that overrides a virtual function in the parent class, you must use both the virtual and the override keywords. For example:
    class A
    {
    public:
        virtual void F() {}
    };
    
    class B : public A
    {
    public:
        virtual void F() override;
    }


UObjects should be passed around by pointer, not reference. If null is not expected by a function, this should be documented by the API or handled appropriately. For example:

      // Bad
      void AddActorToList(AActor& Obj);
		
      // Good
      void AddActorToList(AActor* Obj);


